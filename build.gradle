import io.github.httpbuilderng.http.*
import groovyx.net.http.*
import static groovyx.net.http.MultipartContent.multipart

plugins {
	id 'java'
    id 'java-library'
    id 'application'
    id 'eclipse'
    id "io.github.http-builder-ng.http-plugin" version "0.1.1"    
}

project.ext {
    version 		= file('version.txt').text.trim()
    incVersion		= false
    // extensionJar 	= project.name + "-" + version + ".jar"
    extensionJar 	= project.name + ".jar"    
	zipName         = project.name + "_" + version + ".zip"

	baseDir 		= projectDir
    uiDir 			= "${baseDir}/ui" 					        // if there are any widgets
    configDir 		= "${baseDir}/configfiles" 			        // folder location of the metadata.xml file
    entitiesDir 	= "${baseDir}/configfiles/Entities"         // folder additional Entities file that you want to be included in the extension
    zipDir 			= "${baseDir}/zip" 					        // where to store the generated zip
    localJarDir 	= "${baseDir}/lib/local" 			        // if you have any jars that should be packed add them here
    commonJarDir 	= "${baseDir}/lib/common" 			        // if you have any jars that should not be packed add them here
    packageVendor 	= "atondorf"               	                // MANIFEST.MF information
    packageName 	= project.name         			            // MANIFEST.MF information
    packageTitle 	= "ThingWorxExtension"   			        // MANIFEST.MF information
    packageVersion 	= version

    // Used for uploading - the address of the Thingworx server
    thingworxServerRoot = "http://127.0.0.1:8080"
    thingworxAppKey     = "1a6441ce-96b6-4998-94ef-c1f894c766e9"
}

configurations {
    packageDependencies
    compile {
        extendsFrom packageDependencies
    }
}

repositories {
    jcenter()
    flatDir { dirs project.ext.commonJarDir    }
    flatDir { dirs project.ext.localJarDir     }     
}

dependencies {
    testImplementation  'org.junit.jupiter:junit-jupiter-api:5.6.2'
    testRuntimeOnly     'org.junit.jupiter:junit-jupiter-engine'

    // all files here will not be packed in the extension.zip
    implementation  fileTree(dir: project.ext.commonJarDir, include: ['*.jar'])
    // this way you can get jars from a central repository ...
        // this way you can get jars from a central repository ...
    implementation group: 'org.json', name: 'json', version: '20171018'
    implementation group: 'io.netty', name: 'netty-all', version: '4.1.30.Final'
    implementation group: 'org.apache.commons', name: 'commons-math3', version: '3.6.1'
    // all files here will be packed into the extension.zip
    packageDependencies fileTree(dir: project.ext.localJarDir, include: ['*.jar'])
}

jar {
    archiveFileName = project.ext.extensionJar
    manifest {
        attributes(["Built-By"  : project.ext.packageVendor,
                    "Build-Date": new Date().format("yyyy-MM-dd HH:mm:ss")])
        attributes(["Package-Title"  : project.ext.packageTitle,
                    "Package-Version": project.ext.packageVersion,
                    "Package-Vendor" : project.ext.packageVendor], project.ext.packageName
        )
    }
}

def updateMetadata() {
    def file = "${buildDir}/zip/metadata.xml"
    def parser = new groovy.util.XmlParser(false, true)
    def xml = parser.parse(file)
    // update the version number to current one ... 
    xml.ExtensionPackages.ExtensionPackage.@packageVersion  = project.ext.version
    xml.ExtensionPackages.ExtensionPackage.@name            = project.name
    // add dependency to own jar
    xml.ExtensionPackages.ExtensionPackage.JarResources[0]?.appendNode(
            "FileResource", [type: "JAR", file: project.ext.extensionJar]
    )
    // add dependencies to required external jars 
    for (File f : configurations.packageDependencies) {
        if (f.getName().startsWith("commons-codec") ||
                f.getName().startsWith("commons-io") ||
                f.getName().startsWith("commons-logging") ||
                f.getName().startsWith("netty") ||
                f.getName().startsWith("log4j") ||
                f.getName().startsWith("httpclient") ||
                f.getName().startsWith("httpcore") ||
                f.getName().startsWith("slf4j")
        ) { continue } // these are the default, provided by thingworx allready ... 
        xml.ExtensionPackages.ExtensionPackage.JarResources[0]?.appendNode(
                "FileResource", [type: "JAR", file: f.getName()]
        )
    }
    PrintWriter pw = new PrintWriter(new File(file))
    pw.write(groovy.xml.XmlUtil.serialize(xml))
    pw.close()
}

clean.doFirst {
    delete fileTree(project.ext.zipDir).matching {
        include "**/*.zip"
    }
}

task twxVersion() {
    group 		    = "TWX Extension"
    description     = "Increment the Version of the extension by 0.0.1"  
    doFirst {
        def incstep 			= '0.0.1'.split(/\./).collect{it.toInteger()}
        def indexedVersion 		= file('version.txt').text.trim()
        def indexedVersionList 	= indexedVersion.split(/\./).toList().withIndex()
        def updatedVersionList 	= indexedVersionList.collect{num, idx -> num.toInteger()+incstep[idx]}
        def updatedVersion 		= updatedVersionList.join(".")

        println( "Updated Version to: " + updatedVersion )

        PrintWriter pw = new PrintWriter( file('version.txt') )
        pw.write( updatedVersion )
        pw.close()
        // update Version Info ...
        project.ext.version = updatedVersion
        project.ext.zipName = project.name + "_" + updatedVersion + ".zip"
    }
}


task twxPrepare( dependsOn: jar ) {
	group       = "TWX Extension"
    description = "Package all Extension files in ZIP-Folder"

    doFirst {
        delete fileTree(project.ext.zipDir).matching {
           include "**/*.zip"
        }
        delete "${buildDir}/zip/"
        // add here all the jars from the packageDependencies configuration
        copy {
            from configurations.packageDependencies
            into "${buildDir}/zip/lib/common/"
        }
        // add the configuration
        copy {
            from "${project.ext.configDir}"
            into "${buildDir}/zip/"
        }
        updateMetadata()
        // add the extension jar itself
        copy {
            from "${buildDir}/libs/${project.ext.extensionJar}"
            into "${buildDir}/zip/lib/common/"
        }
        // add the ui files
        copy {
            from uiDir
            into "${buildDir}/zip/ui/"
        }
        copy {
            from entitiesDir
            into "${buildDir}/zip/Entities/"
        }
    }
}

task twxZip(type: Zip, dependsOn: twxPrepare) {
	group       = "TWX Extension"
    description = "Package Extension to a single zip"
    
    archiveFileName = zipName
    destinationDirectory = new File(project.ext.zipDir)
    from "${buildDir}/zip/"    
}

task twxDelete(type:HttpTask) {
    group           = "TWX Extension"
    description = "Delete old Extension in Thingworx"

    config {
        request.uri = thingworxServerRoot
        request.headers['appKey'] = thingworxAppKey
        request.contentType = 'application/json'  
        request.accept = 'text/html'        
    }
    post {
        request.uri.path = '/Thingworx/Subsystems/PlatformSubsystem/Services/DeleteExtensionPackage'
        request.body = [ packageName: project.name ]
        response.success {
            println ( "Success: Removed Extension from TWX-Server" )
        }
        response.exception {             
            println ( "Error: Extension not present at TWX-Server" )
        } 
    }
}

task twxInstall(type:HttpTask, dependsOn: twxDelete) {
    group       = "TWX Extension"
    description = "Install Extension to Thingworx"
    config {
        request.uri = thingworxServerRoot
        request.headers['appKey'] = thingworxAppKey
        request.headers['X-XSRF-TOKEN'] = 'TWX-XSRF-TOKEN-VALUE'
        request.contentType = 'multipart/form-data'  
        request.accept = 'application/json'        
    }
    post {
        request.uri.path = '/Thingworx/ExtensionPackageUploader'
        request.encoder 'multipart/form-data', OkHttpEncoders.&multipart
        request.body = multipart {
            part 'file', zipName, 'application/zip', new File( zipDir, zipName )
        }
        request.encoder('application/zip') { ChainedHttpConfig config, ToServer req ->
            req.toServer( new ByteArrayInputStream( new File( zipDir, zipName ).bytes ) )
        } 
        response.parser('text/html') { ChainedHttpConfig cfg, FromServer fs ->
            println( "TWX: " + fs.inputStream.text )
        }
        response.exception { t -> 
            println( "ERROR: " + t )  
        } 
    }
}

tasks.named('test') {
    // Use junit platform for unit tests.
    useJUnitPlatform()
}
